# 一.Dart语言注意事项
  - 文件后缀：dart语言后缀以.dart结尾
  - 入口：dart文件的**入口方法为main方法**
  - 分好；dart文件中绝大部分语句都需要加**分号结尾**，**{}后面通常不加分号**

# 二.Dart的变量声明var,常量声明const,常量声明final
  ### 1.final
  - fianl变量再运行时被初始化，其值设置后不能更改
    ```js
      void main(){
        var age = 20;
        print(age);
        age = 21;
        print(age);
        var age1 = 20 + 21;
        print(age1)
      }
    ```
# 三.Dart的常用类型
  ### 1.String字符串
    ```js
      String text = '我是${name}'
    ```
  ### 2.数字类型：int,num,double
  - int:整型数字,int和double不能直接赋值,需要通过**toInt()**和**toDouble()**转化
  - double:小数,**double可以直接给num赋值**，
  - num:可整型可以小数，**num转化为double需要转化toDouble()**
    ```js
      double count = 1.6;
      int count1 = 2;
      count1 = count.toInt();
      count = count1.toDouble();
    ```
  ### 3.布尔类型：bool
  ### 4.列表类型:List
    - (1)在尾部添加：**add()**
    - (2)在尾部添加一个列表：**addAll()**
    - (3)删除满足内容的第一个：**remove()**
    - (4)删除最后一个:**removeLast()**
    - (5)删除索引范围内的数据：**removeRange(start, end)**
      ```js
        List list = ['张三', 12, 'rose', 'lisa', 34, 'jennie','jisoo', '12'];
        list.removeRange(0,2);
        list.removeLast();
        list.remove(34);
        print(list);
      ```
    - (6)循环：**forEach( (item) {})**
    - (7)是否都满足条件:**every( (item) {return 布尔值} )**
    - (8)筛选出满足条件的数据：**where( (item) {return 布尔值} )**
    - (9)列表的长度属性：**length**
    - (10)最后一个元素：**last**
    - (11)第一个元素：**first**
    - (12)是否为空：**isEmpty**
      ```js
        List list = ['张三', 12, 'rose', 'lisa', 34, 'jennie','jisoo', '12'];
        print(list);
        bool isNew = list.every((item) {
          return item.toString().startsWith('小');
        });
        print(isNew);
        print(list.last);
        print(list.first);
        print(list.isEmpty);
        print(list.length);
        print(list.where((item){
          return item.toString().startsWith('j');
        })); // (jennie, jisoo)
      ```
  ### 5.字典类型：Map，Map 属性名 = {key: value}
    - 循环:**forEach**
    - 再添加一个字典:**addAll**
    - 是否包含某个key:**containsKey**
    - 删除某个key:**remove**
    - 清空：**clear**
      ```js
        Map obj = {'name':'lisa'};
        obj.forEach((key, value) {
          print('${key}-${value}');
        });
        obj.addAll({'age': 28});
        print(obj.containsKey('age'));
      ```
  ### 6.动态类型dynamic,允许变量运行时自由改变类型，且会绕过类型校验
    - dynamic和var的区别：**无变异检查，方法和属性直接调用**
      ```js
        dynamic free = 12;
        free = 'free';
        print(free);
      ```

# 四：空安全机制
  在dart语言中通过编译静态检查
  |     **序号**   |  **符号**  |                **解释**              |                 **描述**                    |
  | -------------- | ---------- | -------------------------------------| ------------------------------------------- |
  |    可空类型    |      ?     |              声明可空变量            |       String? --> 允许String或者null        |
  |    安全访问    |      ?.    |    对象为null时跳过操作，返回null    |     user?.name  --> user为null时返回null    |
  |    非空断言    |      !.    |  开发者保证变量非空，否则运行时崩溃  |       name!.length --> 断言name非空         |
  |     空合并     |      ??    |        左侧为null时返回右侧默认值    | name?? 'Guest' --> name为null时返回'Guest'  |
  | -------------- | ---------- | -------------------------------------| ------------------------------------------- |

    ```js
      String? username = null;
      print(username?.startsWith('新')); // null
      String displayName = username ?? 'lisa';
      print(displayName); // 'lisa'
    ```
# 五：常见运算符：+,-,*,/,~/,%,=,+=,-=,*=,/=
# 六：逻辑运算符：&&，||，！
# 七：函数：
  - 有返回值，返回值类型可以省略，Dart会自动推断类型为dynamic
  - 无返回值void
  - 可选位置参数：**函数名(String a, [String?b, ...]),使用[]**
  - 可选命名参数：**函数名(String a, {String?b, ...}),使用{}**
  - 匿名函数：Function 变量名 = (){}
  - 箭头函数: 函数名()=>代码逻辑
  ```js
    int add (int a, int b) {
      return a + b;
    };
    print(add(3,4));
    void test () {
      print('test');
    };

    String combine (String a, [String? b, String? c]) {
      return a + (b ?? '' ) + ( c ?? ''); 
    };
    print(combine('lisa', '--'));

    Function test = () {
      print('test');
    };
    test();
  ```

# 八：类
  ### 1.类的定义
  ### 2.默认构造函数（又称为同名构造函数：函数名和类名相同）:使用构造函数直接给对象中的属性赋值
    ```js
      // 定义语法：
      class 类名 {
        类名(可选命名参数){

        }
      }
      // 实例化语法：
      Person p = Person(属性名：值)
      // ===============================
      class Person {
        String? name = 'lisa';
        int? age = 0;
        String? sex = '男';
        Person ({String?name,int? age, String?sex}) {
          this.name = name;
          this.age = age;
          this.sex = sex;
        }
        void study(){
          print('姓名${name}年龄${age}性别${sex}');
        }
      }
      void main (List<String> args) {
        // 实例化
        Person p = Person(name:"lisa",age:28,sex:'女');
        p.study();
      }
    ```
  ### 3.命名构造函数：构造函数可以采用命名的方式，返回一个实例化对象
    ```js
      // 定义语法：
      class 类名 {
        类名.构造函数名(可选命名参数){

        }
      }
      // 实例化语法：
      Person p = Person.构造函数名(属性名：值)
      // ===============================
      class Person {
        String? name = 'lisa';
        int? age = 0;
        String? sex = '男';
        Person.createPerson({String?name,int? age, String?sex}) {
          this.name = name;
          this.age = age;
          this.sex = sex;
        }
        void study(){
          print('姓名${name}年龄${age}性别${sex}');
        }
      }
      void main (List<String> args) {
        // 实例化
        Person p = Person.createPerson(name:"lisa",age:28,sex:'女');
        p.study();
      }
    ```
  ### 4.构造函数语法糖:以上两种构造函数均支持语法糖简写
    ```js
      class 类名{
        类名({this.属性1, this.属性2});
        // 或者
        类名.命名函数({this.属性1, this.属性2});
      }
      // =============================================
      class Person {
        String? name = 'lisa';
        int? age = 0;
        String? sex = '男';
        Person({this.name,this.age});
        void study(){
          print('姓名${name}年龄${age}性别${sex}');
        };
      }
      void main (List<String> args) {
        // 实例化
        Person p = Person(name:"lisa",age:28,sex:'女');
        p.study();
      }
    ```

  ### 5.公有属性和私有属性，私有属性以_开头，只能在类内部调用
  ### 6.类的继承
  - 语法：**class 类名extends 父类**
  - 重写父类方法：子类通过@override注解重写父类方法，拓展其行为
  - super关键字：**子类无法继承父类构造函数**，必须通过super关键字调用父类构造函数
  - super语法：**子类构造函数(可选命名参数):super({参数})**
    ```js
      class Parent {
        String? name;
        int? age;
        Parent({this.name, this.age});
        void study () {
          print('父类-${name}在学习');
        }
      }

      class Child extends Parent {
        // super语法
        Child({String? name, int? age}) : super(name:name,age:age);
        @override
        void study() {
          // super.study();
          print('子类${name}年龄${age}');
        }
      }
      void main (List<String> args) {
        Child c = Child(name:'lisa',age:20);
        c.study();
      }
    ```
  ### 7.类的多态,实现方式有两种：(1)继承和方法重写，(2)抽象类和接口abstract或者implements
  - (1)继承和方法重写
    ```js
      // ===============继承和方法重写===============
      class Pay {
        void pay () {
          print('基础支付')
        }
      }
      class WXPay extends Pay {
        @override
        void pay () {
          print('微信支付')
        }
      }
      class ALIPay extends Pay {
        @override
        void pay () {
          print('支付宝支付')
        }
      }
    ```
  - (2)抽象类和接口abstract或者implements：**第一步：先用abstract关键字定义一个抽象类(没有实现体)，第二步：使用implements关键字继承并实现抽象类**
    ```js
      // ===============抽象类和接口abstract或者implements===============
      // 第一步：先用abstract关键字定义一个抽象类(没有实现体)
      abstract class Pay {
        void pay();
      }
      // 第二步：使用implements关键字继承并实现抽象类
      class WXPay implements Pay {
        @override
        void pay() {
          print('微信支付');
        }
      }
      class ALIPay implements Pay {
        @override
        void pay() {
          print('支付宝支付');
        }
      }
      void main (List<String> args) {
        Pay p1 = WXPay();
        Pay p2 = ALIPay();
        p1.pay();
        p2.pay();
      }
    ```
  ### 8.类的混入：dart允许在不使用传统继承的情况下，向类中添加新的功能，使用mixin关键字定义一个对象
    ```js
      mixin Base {
        void song (String name) {
          print('${name}song')
        }
      }
      class Studeng with Base {
        String? name;
        int? age;
        Student({this.name, this.age});
      }
      class Teacher with Base {
        String? name;
        int? age;
        Teacher({this.name, this.age});
      }
    ```


# 九：泛型:泛型集合，泛型方法，泛型类
  ```js
    void main (List<String> args) {
      Map<String, int> = {};
      getValue<String>('1');
    }
    T getValue<T>(T value){
      return value;
    }
  ```

# 十：异步编程--事件循环
  ### 2.future代表一个异步操作的最终结果。
  - 状态：**Uncompleted**(等待),**Completed with a value**(成功)，**Complated with a error** (失败)
  - 创建：**Future((){})**
  - 执行成功**then((){})**
  - 执行失败:throw Exception() 失败状态：**catchError((){})**
    ```js
      Future f = Future((){
        return 'Hello Flutter'
      });
      f.then((value){
        print(value);
      });
    ```
  ### 3.链式调用
    ```js
      Future f = Future((){
        return 'Hellow World'
      });
      f.then((value){
        return Future(() => 'task1');
      }).then((value){
        return Future(() => 'task2')
      }).then((value){
        throw Exception('异常')
      }).catchError((error){
        print('出现错误')
      })
    ```

  ### 4.async await
    ```js 
      void test()async{
        try{
          await Future((){
            throw Exception();
          })
        } catch(error){
           print('异步请求出现错误');
        }
      }
    ```
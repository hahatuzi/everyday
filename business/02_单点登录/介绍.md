# 一：单点登录流程
  未登录用户访问应用1   ---->   跳转至SSO登录认证客户端  -->  认证登录并跳转回应用1
  未登录用户访问应用2   ---->   跳转至SSO登录认证客户端  -->  认证登录并跳转回应用2
**如果是一个旧的项目，在SSO改造时直接将跳转至登录页修改成登录认证页即可**
# 二：设计重点：
（1）统一认证登录页
（2）登录信息提交至后台认证服务器
（3）认证信息存储在顶级域名的cookie中
（4）重定向回访问应用



  ```js
    private static final void doSetCookie(HttpServaletRequest request, httpServletResponse response, String cookieName, String cookieValue, int cookieMaxage, boolean isEncode) {
      try {
        if (cookieValue == null) {
          cookieValue = ''
        } else if (isEncode) {
          cookieValue = URLEncoder.encode(cookieValue, 'utf-8')
        }
        Cookie cookie = newCookie(cookieName, cookieValue)
        if (cookieMaxage > 0) {
          cookie.setMaxAge(cookieMaxage)
          if (null != request) {
            String domainName = getDomainName(request)
            if (!'localhost'.equals(domainName)) {
              cookie.setDomain(domainName)
            }
          }
          cookie.setPath('/')
          response.addCookie(cookie)
        }
      } catch () {

      }
    }
  ```

  # 解决方案一：session跨域
  session跨域就是摒弃了系统提供的session,而使用自定义的类型session的机制来保存客户端数据的一种解决方案
  比如：通过**设置cookie的domain来实现cookie的跨域**传递。在cookie中传递一个自定义的session_id.这个session_id是客户端的唯一标记，将这个标记作为key,用户数据作为value。这种机制就是session的跨域解决。
  # 解决方案二：认证中心
    用户登录 -->  系统A登录页 --> 跳转至认证中心页面 --> 认证中心存储token  --> 登录成功重定向到系统A登录页
  # 解决方案三：localStorage跨域
    locaStorage跨域的情形：
    - 1.iframe
    - 2.postMessage API 
      ```js
        let token = res.data.token
        let iframe = document.createElement('iframe')
        iframe.src = 'http://app1.com/XXX.html'
        document.body.append(iframe)
        setTimeout(function () {
          iframe.contentWindow.postMessage(token, 'http://app1.com')
        },4000)
        window.addEventListener('message', function (e) {
          localhost.setItem('token', e.data)
        })
      ```
客户端请求  --> 


[!参考链接：单点登录SSO]https://blog.csdn.net/qq_29425101/article/details/139860008
[!前端常见登录方式]https://blog.csdn.net/zhenshu_guo/article/details/135302721
# 一：迭代器和生成器
  ### 1.可迭代对象：
  要成为**可迭代对象**，该对象必须实现 [Symbol.iterator]() 方法，即具有 [Symbol.iterator]()属性，[Symbol.iterator]是一个无参数的函数，其返回值为一个**符合迭代器协议**的对象。
  ```js
    // 可迭代对象
    const myIterator = {
      next () {
        return { done: true, value: undefined}
      },
      [Symbol.iterator]() {
        return this;
      }
    };
  ```
  ### 2.可迭代对象的应用
  - for...of,对象解构，yield*,
  - new Map([Iterator]), new WeakMap([iterator]), new Set([iterator]), new WeakSet([iterator])
  - Promise.all(iterator), Promise.race(iterator), Array.from(iterator)

  ### 3.迭代协议：迭代协议包括可迭代协议和迭代器协议两部分
  - 可迭代协议：可迭代协议允许 JavaScript 对象定义或定制它们的迭代行为。要成为**可迭代对象**，该对象必须实现 [Symbol.iterator]() 方法。
  - 迭代器协议: 迭代器协议定义了产生一系列值（无论是有限个还是无限个）的标准方式，当值为有限个时，所有的值都被迭代完毕后，则会返回一个默认返回值。


  ### 4.迭代器
  - **迭代器和生成器**将迭代的概念直接带入核心语言，并提供了一种机制来**自定义for...of循环**的行为
  - **迭代器**是一个对象，是一个通过使用**next()**方法**实现了迭代器协议**的任何一个对象，它定义一个序列，并在终止时可能附带一个返回值。
    ```js
      // 迭代器对象
      const myIterator = {
        // next函数的返回值必须包含done和value属性
        next () {
          return { done: true, value: undefined}
        }
      };
      const value1 = myIterator.next()
      const value2 = myIterator.next()
    ```
  - 迭代器可以中断：比如遍历的时候通过**break,return,throw**中断循环
  ### 5.生成器
   - 生成器替代迭代器
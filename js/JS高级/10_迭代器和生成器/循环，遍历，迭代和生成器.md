# 一：迭代器和生成器
  ### 1.可迭代对象：
  要成为**可迭代对象**，该对象必须实现 [Symbol.iterator]() 方法，即具有 [Symbol.iterator]()属性，[Symbol.iterator]是一个无参数的函数，其返回值为一个**符合迭代器协议**的对象。
  ```js
    // 可迭代对象
    const myIterator = {
      next () {
        return { done: true, value: undefined}
      },
      [Symbol.iterator]() {
        return this;
      }
    };
  ```
  ### 2.可迭代对象的应用
  - for...of,对象解构，yield*,
  - new Map([Iterator]), new WeakMap([iterator]), new Set([iterator]), new WeakSet([iterator])
  - Promise.all(iterator), Promise.race(iterator), Array.from(iterator)

  ### 3.迭代协议：迭代协议包括可迭代协议和迭代器协议两部分
  - **可迭代协议**：可迭代协议允许 JavaScript 对象定义或定制它们的迭代行为。要成为**可迭代对象**，该对象必须实现 [Symbol.iterator]() 方法。
  - **迭代器协议**: 迭代器协议定义了产生一系列值（无论是有限个还是无限个）的标准方式，当值为有限个时，所有的值都被迭代完毕后，则会返回一个默认返回值。


  ### 4.迭代器
  - **迭代器和生成器**将迭代的概念直接带入核心语言，并提供了一种机制来**自定义for...of循环**的行为
  - **迭代器**是一个对象，是一个通过使用**next()**方法**实现了迭代器协议**的任何一个对象，它定义一个序列，并在终止时可能附带一个返回值。
    ```js
      // 迭代器对象
      const myIterator = {
        // next函数的返回值必须包含done和value属性
        next () {
          return { done: true, value: undefined}
        }
      };
      const value1 = myIterator.next()
      const value2 = myIterator.next()
    ```
  - 迭代器可以中断：比如遍历的时候通过**break,return,throw**中断循环
  ### 5.生成器，**生成器是**ES6新增的一种函数控制，使用的**函数**，它更灵活的控制函数什么时候继续执行，暂停执行等。 
  - 生成器函数需要再function后面加一个符号*：**-function*-**
  - 生成器函数可以通过**yield**关键字**控制函数的执行流程**
  - 生成器函数的返回值是一个Generator（生成器）
    ```js
      // 生成器：返回一个迭代器, 
      function* generotor (arr) {
        for (let v of arr) {
          yield v
        }
      }
      const iterator = generotor([1,2,3,4,5])
      console.log(iterator.next())
      console.log(iterator.next().value)
      console.log(iterator.next().value)
    ```
  - 生成器替代迭代器

# 二：理解和区分循环，遍历和迭代
  - 循环：语言层面上的语法：重复执行一段程序
  - 遍历：业务层面上的做法：观察或者获取集合中元素的一种做法
  - 迭代：实现层面上的概念：迭代其实就是实现遍历的底层方案
# 三：for...in和for..of
  ###　(1)for...in,迭代对象的所有可枚举属性，包括继承的可枚举属性
    ```js
    // 以任意顺序遍历一个对象的除Symbol以外的可枚举属性**，**包括继承的可枚举属性**
    // 会遍历到原型上的方法，所以在遍历的时候常常用Object.hasOwnPropery判断一下是否是该对象的实例对象。
      Object.prototype.fn = function () {
        console.log('原型fn')
      }
      var obj1= {
        name: 'lisa'
      }
      for (var key in obj1) {
        if (obj1.hasOwnProperty(key)) {
          console.log(key) // fn, name
        }
      }
    ```
  **注：不建议使用for in  去遍历更关注索引的数组**

  ### (2)for...of,循环处理可迭代对象的值序列
    ```js
      // 在**可迭代对象**(Array,Map,Set,String,arguments)上创建一个迭代循环
      (function () {
        for (let argument in arguments){
          console.log(argument)
        }
      })(1,2,3)
      for (let s of '12345') {
        console.log(s)
      }
      let m = new Map([[{a:1}, 1],[{b:2}, 2]])
       for (let [k,v] of m) {
        console.log(k,v)
      }
    ```
  ### (3)区别：
  for in 遍历的是**对象的可枚举属性**。而for of 遍历的是**可迭代对象**，这意味着这个对象（或其原型链中的任意一个对象）必须具有一个带 Symbol.iterator 键（key）的属性。内置的可迭代对象包括String,Array,Map,Set

[!参考视频codewhy--迭代器和生成器]https://www.bilibili.com/video/BV1TY411B71U?spm_id_from=333.788.player.switch&vd_source=afbd897dda8c1c6166fce57f249edafd&p=12
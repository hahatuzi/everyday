# 事件流
  事件流包括捕获流和冒泡流两个过程。
  ```js
    // element.addEventListener(event, function, useCapture)
    // 参数三：useCapture	可选。布尔值，指定事件是否在捕获或冒泡阶段执行，默认为false,在冒泡阶段执行。
    <div class="test"></div>
    var testDiv = document.querySelector('.test')
    testDiv.addEventListenter('click', function () {
      alert('click')
    }, true)
  ```
# 事件对象的常见属性及方法简单复习
注：事件对象存在兼容性问题，IE6-8不支持event对象，它支持window.event
## 一：事件对象的属性：
  - 1.event.type  事件的类型，如click
  - 2.event.target  触发事件的对象，标准
  - 3.event.stopPropagation()  阻止事件冒泡,标准
  - 4.event.preventDefault()  阻止默认行为，标准
  - 5.window.event.srcElement  触发事件的对象，非标准,IE6-8使用
  - 6.window.event.cancelBubble  该属性用于阻止事件冒泡，非标准,IE6-8使用
  - 7.window.event.returnValue  该属性用于阻止默认行为，非标准,IE6-8使用

  注：在事件中e.target和this的区别：
  **e.target指向触发事件的对象，this指向绑定事件的对象，**

## 二：事件委托
  #### 1.概念:适用场景，如果你想要在大量子元素中单击任何一个资格都可以运行一段代码，你可以将事件监听器设置在它们的父节点上，并让子节点上发生的事件冒泡到父节点上，而不是每一个子节点单独设置事件监听器！！
  ```js
    <ul>
      <li></li>
      <li></li>
      <li></li>
    </ul>
    var ul = document.querySelector('ul')
    ul.addEventListener('click',()=>{
        console.log(this, e.target || window.event.srcElement)
    })
    // 当点击li时，触发对象是li，而绑定的对象则是ul。
  ```
## 三：事件冒泡:，刚开始由最具体的元素开始，然后逐步向外传播到DOM最顶层节点。
  ```js
  // 阻止事件冒泡
    var div =  document.querySelector('div')
    div.onclick = (e)=>{
      if (e && e.stopPropagation) {
        e.stopPropagation()
      } else{
        window.event.cancelBubble = true
      }
    }
  ```
 - 支持事件冒泡的事件和不支持的事件列表：不支持的事件：abort,blur,error,focus,load,upload,mouseenter,mouseleave,resize
## 四：默认行为
  ```js
  // 阻止默认行为
    var div =  document.querySelector('div')
    div.onclick = (e)=>{
      if (e && e.preventDefault) {
        e.preventDefault()
      } else{
        window.event.returnValue = true
      }
    }
  ```

## 五：解决了时间捕获和事件冒泡，那么事件委托又是什么呢？
 - 它依赖于事件冒泡，说白了就是人们发现，如果最里层有多元素需要添加相同的事件时，如果每个元素都添加事件太麻烦。而且发现在事件冒泡时还要执行外层的元素的事件。所以就偷懒将事件委托给了外层元素，然后我们可以偷偷通过e.target查看一下我们触发事件的真实对象。



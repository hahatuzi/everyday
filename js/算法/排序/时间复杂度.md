# 分析方法：事后分析估算法，事前分析估算法
## 一.事后分析估算法：程序运行前计时，程序运行后计时
## 二.事前分析估算法：
### 1.决定因素：
（1）算法采用的策略和方案
（2）编译的代码质量
（3）问题的输入规模，输入量的大小
（4）机器执行指令的速度
### 2.算法输入规模测算
输入规模     | 2n+3执行次数| 2n执行次数| 3n+1执行次数| 3n执行次数
--------    | ----------| ---------| -----------| --------｜
n=1         | 5         |    2     |       4    |     3   |
n=3         | 9         |    6     |       10   |     9   |
n=1         | 23        |    20    |       31   |     30  |
n=1         | 203       |   200    |      301   |     300 |
**渐进增长速度即为倾斜度对比**
### 3.算法模型对比结论：
（1）算法函数中的常熟可以忽略
（2）算法函数中最高次幂的常数系数可以忽略
（3）算法函数中最高次幂越小，算法效率越高
# 大O记法
记法规则：
（1）用1代替所有加法常数
（2）运行次数仅保留最高阶项
（3）如果最高阶项存在，且 常数因子不为1，我们去除这个项的常数
比如：(2n^3+3) --> (n^3)
# 函数调用的时间复杂度
```js
function fn () {
  int n =100
  for(var i = 0, i<n; i++){ 
    this.show() //执行1次
  }
}
function show () {
  console.log('ok)
}
fn()
// 时间复杂度为O(n)
```
```js
function fn () {
  // for循环自身执行n次
  for(var i = 0, i<n; i++){
    this.show()
  }
}
function show () {
  // 自身执行n次
  for(var i = 0, i<n; i++){
    sum +=i
  }
}
fn()
// 时间复杂度为O(n^2)
```
# 最好情况，最坏情况，平均情况
```js
function fn () {
  var arr = []
  // for循环自身执行n次
  for(var i = 0, i<n; i++){
    this.show()
  }
}
function show () {
  // 自身执行n次
  for(var i = 0, i<n; i++){
    sum +=i
  }
}
fn()
// 时间复杂度为O(n^2)
```
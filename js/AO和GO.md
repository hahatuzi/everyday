# 本文讲述浏览器的底层运行机制：
**1.js的运行环境：**
V8引擎以前采取的是两个编译器一起工作来实现将js代码转化为机器码的原理，后来，，忘记了
**2.ECS(executioin context stack)执行环境栈**
### ECS
内存中分配出来的一块内存，遵守先进后出的原则，
作用：用来存储执行代码期间创建的所有EC(执行上下文)
**3.EC(executioin context)执行上下文(语法作用域)**
### EC
// 执行上下文和堆栈无关，堆栈中存储的只是变量。而上下文其本质是作用域。
执行上下文包括两种类型：
（1）EC(G):全局执行上下文
    ｜当打开页面时。首次加载一个JS文件或者运行一段JS代码时，会先创建一个EC(G)
    |当页面关闭时才会释放掉EC(G)
    | 刷新页面时，会把之前的上下文都释放掉，然后重新创建全新的上下文，**并且把它压入执行栈的顶部**。
（2）EC(XX):XX函数私有执行上下文
    |在全局执行上下文创建并压栈后，在运行EC(G)中的代码时，**每次有函数被调用就会创建一个函数私有执行上下文并压栈**，（这个私有上下文可以保护里面的私有变量和外界互不干扰 闭包的保护机制】）
    ｜**即便是同一个函数被执行多次，每次调用的时候都会再创建一个新的私有上下文**
    ｜只要当前上下文中的某些内容，被当前上下文以外的东西占用，那么当前上下文是不能被释放的（上下文当中存储的变量等信息也保存下来了）
**4.闭包**
闭包是一种机制
闭包的作用：保护/保存
（1）它是函数运行时产生的机制，函数执行会在执行环境栈【ECStack】中形成一个全新的私有上下文【EC(私有)】并且在私有上下文中声明新的作用域【scope】和作用域链【scope-chain】，可以保护里面的私有变量【Ao】和外界【Vo】互不干扰 【保护机制】
（2）且若私有上下文中的某些内容，被当前上下文以外的东西占用，那么当前上下文是不能被出栈释放的（这样私有变量及它的值等也不会被释放掉）【保存机制】
大量应用闭包一定会导致内存消耗，但是闭包的保护和保存作用，在真实开发中我们还是需要使用，所以要合理使用闭包
**5.VO(Variable Object)变量对象**
是一个存储空间：是一个用来保存当前上下文中的所有变量的对象
变量对象包括两种类型：和执行上下文一样
（1）VO(G)全局变量对象：
   ###### 在EC(G)中创建的VO(G)的具体表现就是GO(全局对象)，注意前提是在EC(G)下创建的VO(G)
   VO(G)【全局变量对象】和GO【全局对象】的关系：
   即：VO（G）
      两者之间存在映射机制【创建一个全局变量，也相当于给GO设置一个属性】 单向的！！！！不存在给GO设置一个属性会映射给Vo(G)的情况，【不包括基于let/const创建的变量】
   而VO(G)又区分为var创建和let,const创建的两种类型：
   var创建的类型：会映射给GO一份作为其属性
（2）AO私有变量对象：
    而在【函数执行上下文EC(XX)中】，因为【私有变量对象 AO(xx)】 是要保存当前私有上下文中所有的变量，而一个函数内的变量包括：形参变量、局部变量、自身函数对象引用变量、arguments、this。 为了保存这些变量，所以特意创建了一个对象，称它为【活动对象(私有变量对象)AO(xx)】，函数内所需的变量就都保存在 【私有变量对象AO(xx)】 中，所以在函数执行上下文中，变量对象 VO 的具体表现也就是【私有变量对象AO(xx)】
引用原文链接：https://juejin.cn/post/6874592740395450376

**6.垃圾回收机制**
代码回收规则如下：
1.全局变量不会被回收。
2.局部变量会被回收，也就是函数一旦运行完以后，函数内部的东西都会被销毁。
3.只要被另外一个作用域所引用就不会被回收
// 这也就是闭包的产生来源。
如下题：
```js
// 请问有几个变量没有被回收
var i = 1;
var i = 2;// 全局变量i不会被回收
var add = function() {  // 全局变量add不会被回收
  var i = 0;
  return function()
  {
    i++; // 引用的局部变量i不会被回收
    console.log(i);
  }
}();
add();
```
**7.作用域链**
# 一：理解和区分循环，遍历和迭代
  - 循环：语言层面上的语法：重复执行一段程序
  - 遍历：业务层面上的做法：观察或者获取集合中元素的一种做法
  - 迭代：实现层面上的概念：迭代其实就是实现遍历的底层方案
# 二：for...in和for..of
  ###　(1)for...in,迭代对象的所有可枚举属性，包括继承的可枚举属性
    ```js
    // 以任意顺序遍历一个对象的除Symbol以外的可枚举属性**，**包括继承的可枚举属性**
    // 会遍历到原型上的方法，所以在遍历的时候常常用Object.hasOwnPropery判断一下是否是该对象的实例对象。
      Object.prototype.fn = function () {
        console.log('原型fn')
      }
      var obj1= {
        name: 'lisa'
      }
      for (var key in obj1) {
        if (obj1.hasOwnProperty(key)) {
          console.log(key) // fn, name
        }
      }
    ```
  **注：不建议使用for in  去遍历更关注索引的数组**

  ### (2)for...of,循环处理可迭代对象的值序列
    ```js
      // 在**可迭代对象**(Array,Map,Set,String,arguments)上创建一个迭代循环
      (function () {
        for (let argument in arguments){
          console.log(argument)
        }
      })(1,2,3)
      for (let s of '12345') {
        console.log(s)
      }
      let m = new Map([[{a:1}, 1],[{b:2}, 2]])
       for (let [k,v] of m) {
        console.log(k,v)
      }
    ```
  ### (3)区别：
  for in 遍历的是**对象的可枚举属性**。而for of 遍历的是**可迭代对象**，这意味着这个对象（或其原型链中的任意一个对象）必须具有一个带 Symbol.iterator 键（key）的属性。内置的可迭代对象包括String,Array,Map,Set
  ### (4)生成器，迭代器和symbol.iterator
  - **迭代器**和**生成器**将**迭代**的概念直接带入核心语言，并提供了一种机制来**自定义 for...of 循环**的行为。
  - 迭代器协议
  - function*声明创建一个绑定到给定名称的新生成器函数。生成器函数可以退出，并在稍后重新进入，其上下文（变量绑定）会在重新进入时保存。
    ```js
      // 生成器：返回一个迭代器, 
      function * generotor (arr) {
        for (let v of arr) {
          yield v
        }
      }
      const iterator = generotor([1,2,3,4,5])
      console.log(iterator.next())
      console.log(iterator.next().value)
      console.log(iterator.next().value)

      // 自定义实现生成器
      const o = {
        0:1,
        1:2,
        2:3,
        length:3
      }
      Object.prototype[Symbol.iterator] = iterator
      function iterator () {
        var _this = this
        let nextIndex = 0
        return {
          next () {
            return nextIndex < _this.length ? {value:_this[nextIndex++], done:false} : {value:undefined, done:true}
          }
        }
      }
      // 遍历的底层就是迭代，for..of的底层原理就是自定义的iterator
      for (const v of o) {
        console.log(v)
      }
    ```
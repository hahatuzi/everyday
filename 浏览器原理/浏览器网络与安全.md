[!参考视频] https://www.bilibili.com/video/BV1UL41157hP?p=6&vd_source=afbd897dda8c1c6166fce57f249edafd
[!浏览器渲染底层]https://www.bilibili.com/video/BV1yT411q7YQ/?spm_id_from=333.337.search-card.all.click&vd_source=afbd897dda8c1c6166fce57f249edafd
[!参考文章-浏览器工作原理与实践]https://blog.poetries.top/browser-working-principle/

# 一：宏观浏览器
  ```js
    // C/S client  --server 王者荣耀
    // B/S browser --server 语雀
  ```
# 二：进程和线程
  进程就是在内存中正在运行的应用程序，一个进程由多个线程组成，
  ###  1.一个页面启动的时候最少包含几个进程,4个进程
  - **主进程**：负责管理整个浏览器的UI，标签，书签等基本功能，负责页面显示，用户交互，子进程管理，同时还有存储功能
  - **GPU进程**：GPU图形处理器，chrome的UI界面是采用GPU来绘制的
  - **渲染进程**：将HTML,JS,CSS转换为页面，**GUI渲染进程**排版引擎和**JS引擎V8线程**，**时间触发线程**都在该进程中，默认每个tab页都会创建一个渲染进程
  - **网络进程**：负责页面网络资源加载
  此外还有**插件进程**：负责插件的运行
  ### 1.浏览器的渲染进程中包含哪些线程
  - (1)主线程(JS执行线程)，包括**JS引擎模块**，**HTML,CSS文件解析模块**，**DOM/CSS模块**，**布局和渲染模块**。
      负责解析HTML,css，渲染页面，处理用户交互（点击、滚动），是单线程执行的，当HTML解析遇到script标签是，会暂停主线程，通过JS线程执行JS脚本。长时间任务会导致页面卡顿。如果在js代码中重复修改dom的display属性，页面会以最哦呼的修改效果为显示效果
      ```js
      btn.onClick = function () {
        let start = Date.now()
        setTimeout(() => {
          console.log('setTimeout', Date.now() - start)
        },1000)
        for(let i = 0, i<100000, i++){}
      }
      ```
  - (2)JS引擎线程;执行JS代码，不同浏览器使用不同的引擎（chrome-v8,firefox-spiderMonkey），单线程特性导致长时间计算会阻塞页面渲染
  - (3)定时器线程，管理setTimeout,setInterval等定时任务，到期后将任务添加到**JS引擎任务队列**
  - (4)事件监听线程，监听用户操作（点击、滚动），将事件回调函数加入到**JS引擎任务队列**
  - (5)WebWorker线程，独立于主线程的多线程解决方案，用于执行耗时任务（复杂计算），通过postMessage与主线程通信
  - (6)异步http网络请求线程：负责ajax请求
  **部分浏览器还会细分渲染流程为 GPU线程 （处理图形绘制,处理页面的绘制和渲染）和 网络线程 （管理网络请求），但主流浏览器通常将渲染任务整合至主线程或GPU线程处理。**
# 三：计网七层模型
- 物理层：光纤，网线
- 数据链路层：MAC地址
- 网络层:IP协议
- 传输层：UDP协议，TCP协议
- 会话层：断点重连
- 表示层：翻译
- 应用层：HTTP协议
  **UDP和TCP的区别**
  UDP协议只管发不管接收，比如微信电话，
# 四：HTTP
  ### 1.http发展过程
  - http0.9：只用来**传输html文件**，传输的数据比较简单，只有请求行，没有请求头和响应头
  - http1.0：**增加了post请求**，**通过请求头和响应头进行协商**，状态吗，cookie等从而达到浏览器从服务器那里获取到想要的格式类型文件的目的
  - http1.1：开启了**keep-alive**对文件传输的速度，持久化连接，提升用户连接效率
    - 缺点：对带宽的利用率不够（TCP的慢启动，），**每个http请求都会建立一个TCP连接**
  - http2.0：基于1.1的阻塞问题提出的2.0**多路复用**解决方案。一个域名只使用一个TCP长连接来传输数据！
  ### 2.造成http1.1慢的原因
  - （1）TCP的慢启动
  - （2）同时开启多条TCP连接时，会竞争带宽
  - （3）http1.0的队头阻塞问题
  ### 3.HTTP请求流程
  - 发送请求 --> 查找缓存 -->  准备IP和端口号 --> 等待TCP队列（一个域名最多同时建立6个TCP连接） -->  建立TCP链接 --> 发送HTTP请求
# 五:强缓存和协商缓存  disk cache和memory cache
  ### 强缓存：
  - 1.强缓存特点：
    - （1）不会向服务器发送请求，直接从本地缓存中获取数据。
    - （2）请求资源的状态码为**200 ok(from disk cache)**。
    - （3）强缓存是通过设置http响应头中的**Cache-Control**和**Expires**来控制浏览器本地缓存的有效期。
    - （4）强缓存一定要设置**过期时间**，否则会导致系统升级时的缓存问题！！！
  - 2.强缓存命中条件：
    - （1）响应头中有**Expires**，Expires是由**http1.0**提出的表示资源过期时间的Header.如果电脑本地时间修改，缓存资源可能不失败！！！
    - （2）**Cache-Control: max-age = XXX**，它出现在**http1.1**，优先级高于Expires，它表示的相对时间，而Expires则是电脑绝对时间
    - （3）响应头中**ETag**和**Last-Modified**,且不存在**Cache-Control:no-cache**
  ### 协商缓存
  - 1.协商缓存特点：
    - （1）协议缓存是通过**ETag**和**Last-Modified**来实现的。
    - （2）浏览器在请求资源时会将ETag和Last-Modified发送给服务器，服务器根据这些信息判断资源是否发生变化，如果是，服务器返回**304Not Modified**状态码，通知浏览器从缓存中读取资源。这样可以减少网络传输和服务器负载。
  - 2.协商缓存全流程：
    - （1）第一次请求服务器，服务器返回200状态码、Last-Modified时间戳、ETag签名和完整资源。
    - （2）浏览器保存资源内容,以及Last-Modified和ETag值
    - （3）再次请求浏览器带上请求头**If-Modified-Since**（值为上次服务器返回的Last-Modified）和请求头**If-None-Match**（上次服务器返回的ETag）
    - （4）服务器收到请求后,**对比当前资源文件的最后修改时间** 是否等于 If-Modified-Since 以及资源文件的ETag 是否等于 If-None-Match （**ETag优先级高于Last-Modified**）
    - （5）如果相同则返回304，客户端使用缓存
    - （6）如果不相同则服务器返回资源，且返回新的ETag 和 Last-Modified，并更新到缓存
  - 3.字段概念
    - **Cache-Control**，max-age，no-store不允许缓存,no-cache需要验证是否为新鲜数据再绝定是否使用缓存
    -  **Last-Modified If-Modified-Since**：资源在服务器上的**最后修改时间**
    -  **If-Modified-Since**：为上一次请求时返回的last modified的值
    - **ETag**和**If-None-Match**：这两个是由服务器生成的每一个资源的唯一标识字符串，**每次当资源发生改变时ETag值也会发生改变，和最后修改时间无关**。
  - 4.ETag解决了Last-Modified的一些问题：
    - （1）**文件周期性的改变但是内容没有改变**的情况。这种情况下因为修改时间改变了Last-Modified就会改变,导致重复请求资源，但是实际上文件内容未改变！！
    - （2）文件修改频率在毫米级别,Last-Modified只能控制到秒。
    - （3）某些服务器不能请求得到文件的而最后修改时间！
  ### 强缓存导致的升级刷新问题解决
    - （1）给强缓存添加过期时间
      ```js
        location ~* \.html$ {
          add_header Cache-Control max-age = 60 // 清缓存的缓存时间设60s
        }
      ```
    - （2）使用协议缓存，不再使用强缓存 Cache-Control: no-cache
    - （3）不使用缓存，每次都刷新
[!参考文章：一个Bug搞懂浏览器缓存策略]https://cloud.tencent.com/developer/article/2397942
[!参考文章--强缓存和协商缓存使用场景]https://juejin.cn/post/7215056364166479931
# 六：从进程的角度考虑从URL到页面渲染，浏览器做了什么

# 七：浏览器安全
  浏览器的安全主要讨论页面安全，网络安全，浏览器系统三部分。
  ### 1.同源策略，跨域的解决方案：CORS，本地node代理服务器，nginx反向代理，iframe的postMessage
  ### 2.XSS攻击：跨站脚本攻击，恶意代码注入。
  - xss攻击案例
    - 窃取cookie信息 
    - 监听用户行为，恶意js会使用addEventListener建通键盘事件，获取用户输入的信息
    - 修改DOM，伪造登录页面等
    - 生成浮窗广告
  - 恶意脚本注入方式：存储型XSS攻击，反射型XSS攻击，基于DOM的XSS攻击
    - **存储型XSS攻击**:黑客将恶意代码存储到存在漏洞的服务器上  --> 用户访问该页面　-->  用户将用户提交恶意代码指向的恶意服务器
    - **反射型XSS攻击**:用户将含有恶意代码的请求提交给服务器 -->  服务器接收到请求后又将代码反射给了浏览器
  - 阻止攻击：
    - 表单提交时对敏感符号进行转义
    - 服务器进行代码过滤
    - CSP（禁止向第三方提交数据，禁止第三方资源加载，禁止未授权监本）
    - httpOnly属性，true表示无法通过脚本读取到cookie数据
  ### 3.CSRF攻击：跨站请求伪造，比如在网站后面加上伪站的地址
    - 阻止手段：token校验，利用cookie的samesite属性，利用origin,referer属性。


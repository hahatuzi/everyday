# 一：可选属性与只读属性
# 二：索引签名
  ```js
    // Record定义
    type DomStyle = string | Record<string, string | string[]> | null
    let style:DomStyle = ['color:red;', 'background:red']
    <div :style="style"></div>
    type AnyObject = Record<string, any>;
    const obj: AnyObject = {
      key1: 'value',
      key2: 123,
      key3: true,
      key4: { nested: 'object' }
    };

      // table表头项
    export type ColumnProps = {
      label: string;
      props: string;
      slot?: boolean;
      type?: string;
      attrs?: Record<string, any>;
    };
    let columnData = ref<ColumnProps[]>([
      { props: "name", label: "房屋名称" },
      { props: "address", label: "房屋地址" },
      { props: "type", label: "房屋类型" },
    ]);
  ```
# 三：元祖类型
  - 元组：确定了元素数量和类型的数组，它能够准确的知道包含了多少个元素，以及索引对应的类型
  ```js
    let x:[string,number] // 确定了长度和类型
    x = ['hello', 10]
    x.push('world') // 越界
    console.log(x)

    const arr: readonly [x:number, y?:number] = [1]
    type first = typeof arr[0]
  ```
# 四：接口interface
  - 继承：如果两个接口之间有相同的属性或者方法，可以将公共的属性或者方法抽离出来，通过继承来实现复用。
  ```js
    interface  point2D { x: number; y: number };
    interface  point3D { x: number; y: number; z: number };

    interface point2D { x: number; y: number };
    interface Point3D  extends Point2D {z: number  };
    interface IPerson {
        name: string
        age: number
        say():void
    };
    let person : IPerson = {
      name: 'lisa'
      age: 18
      say(){}
    }

  ```

# 五：类型别名type与接口interface
  ### type  VS  interface
    |     特性    |                   interface                     |                                  type                                  |
    | ----------- | ------------------------------------------------| -----------------------------------------------------------------------|
    |  用途功能   |          interface用于定义对象的结构            |    type除了定义对象结构，还可以创建联合类型，交叉类型，基本类型别名    |
    |  声明合并   |   interface支持声明合并,同名的interface会合并   |                type不支持声明合并,同名的type会报错                     |
    |  继承拓展   |          interface通过extends继承               |                      type通过交叉类型&实现拓展                         |
    |   实现类    |          类使用implements实现接口               |                         type不能implements                             |
  
    ```js
      // ============用途功能================
      type Money = string | number
      type Container<T> = T[]
      interface PageResult<T> {
        result:<T>;
        total:number
      }
      // ===============声明合并============
      interface Animal {
        name:string
      }
      interface Dog extends Animal {
        breed:string
      }
      type Animal = {
        name:string
      }
      type Dog = Animal & {
        breed:string
      }
      interface Greeter {
        greet():void
      }
      class Person implements Greeter {
        greet(){ }
      }
    ```

# 六： 索引签名类型：支持两种索引签名：字符串和数字。使用场景：当你在使用对象前无法确定对象中有哪些属性时就可以使用索引签名类型
  ```js
    interface  AnyObject  {
      [ key: string ]: number;
      [index:number]: number
    }
    let  obj: AnyObject = {
      a:1,
      1: 1
    }
  ```

# 七：类class
  - （1）class包含属性，constructor构造函数，方法
  - （2）extends实现类的继承
  - （3）修饰符：**public,private, readonly,protect**
  - （4）**抽象类**：以abstract开头的类是抽象类，抽象类和其他类的区别不大，只是不能用来创建对象。抽象类就是专门用来被继承的类，抽象类中可以添加抽象方法。
  - （5）类只读readonly
  - （6）类可以通过implements继承interface
    ```js
      class Animal{
        readonly  age: number = 18
        move(distance:number = 0){
          console.log(`animal移动了${distance}`)
        }
      }
      class Dog extends Animal {
        bark () {
          console.log('woo woo')
        }
      }
      let dog = new Dog()
      dog.move(20)
      // 抽象类
      abstract class Dog{
        // 定义一个抽象方法，抽象方法使用abstract开头，没有方法体，抽象方法只能定义在抽象类中，子类必须对抽象方法进行重写。
        abstract say ():viod
      }
      // ==================implements====================
      interface myInter{
        name:string;
        sayHello():void
      }
      class myclass implements myInter{
        name:string;
        constructor(name:string){
          this.name = name
        }
        sayHello () {
          console.log('Hello')
        }
      }
    ```
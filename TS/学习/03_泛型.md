# 泛型
  泛型（Generics）是指在定义**函数**，**接口**，**类**的时候，不预先指定具体的类型，而是在使用的时候再指定的一种特征。
  ### 1.泛型约束: 通过extends关键字使用，为泛型添加约束
  - 方式一：指定为更加具体的类型
  - 方式二：添加约束
    ```js
      function  fn <T> ( value: T[] ): T{
          console.log(value.length)// 添加约束类型为数组后就可以访问参数的length属性了
          return value
      }

      interface  ILength { length: number  }
      function  fn<T extends  ILength> ( value: T ): T{
          console.log(value.length)
          return value
      }
    ```
  ### 2.多个泛型变量:泛型的类型变量可以有多个，而且变量之间可以相互约束，相互约束的实现通过keyof实现,也可以通过泛型约束实现多类型约束
    - 方式一：keyof 索引类型
    - 方式二：通过泛型约束多类型约束
    ```js
      //   keyof关键字接收一个对象类型，生成其键名称（可能为字符串或者数字）的联合类型
      function  getProps<T extends object, U extends keyof  T>(obj:T, key: U) {
        return obj[Key]
      }
      // keyof  Type把传入的对象类型取出生成一个联合类型，然后泛型U就被约束在这个联合类型中
      let  person = { name: 'lisa', age；18}
      getProps( person, name )
      interface  FirstInterface  { name: string }
      interface  SecondInterfase { age: number }
      interface  Child extends  FirstInterface, SecondInterface  {}
    ```
  ### 3.泛型类,泛型类大创建方式：在类名后面添加<类型变量>
    ```js
      class MyClass<T>{
        name: T;
        constructor (name: T){
          this.name = name
        }
      }
      const mc = new MyClass<string>{name:'孙悟空'}
      class Test<T extends Sentence & Music>{}  // 交叉类型
    ```
  ### 4.泛型接口：在接口名称的后面添加<类型变量>就变成了泛型接口
    ```js
      interface IdFunc<T>{
        id: (value:T) => T
        ids: () => T[]
      }
      let obj:IdFunc<number> = {
        id (value) {  return value }
        ids () { return  [1, 2, 3] }
      }
    ```
  ### 5.泛型别名：
    ```js
      // 在类型别名type的后面使用即可声明一个泛型参数，接口里的其他成员都能使用该参数的类型
      /**
       * 分页响应对象
       */
      interface PageResult<T> {
        /** 数据列表 */
        result: T;
        /** 总数 */
        total: number;
      }
      getReceiveDepByNews(newId: string) {
        return request<any, PageResult<NewsDetailPageVO[]>>({
          url: `/news/getReceiveDepByNews/${newId}`,
          method: "post",
        });
      },
    ```
  ### 6.泛型函数：
    ```js
      // 在函数名称的后面使用即可声明一个泛型参数，整个函数中的变量都可以使用该参数的类型
      function  fn<T> () {}
      interface Inter{
        length:number
      }
      function fn3<T extends Inter>(a: T):number{
        return a.length
      }
      function  createArray (length, value ) {
          let   result = []
          for(let i = 0; i < length; i++) {
              result[i] = value
          }
          return  result
      }
      // 设定value的类型不确定，需要在函数调用的时候再确定
      function createArray<T> (length: number, value:  T ) :T[]{
        let   result = []
        for(let i = 0; i < length; i++) {
            result[i] = value
        }
        return  result
      }
      console.log(createArray<string>(3, 'a'))
      console.log(createArray<number>(3, 1))
    ```
  ### 7.映射类型：[K in keyof T]:T[K]
  - （1）映射类型是**基于索引签名类型**的，所以该语法类似于索引签名类型,也使用[]
  - （2）Key in PropKeys表示Key可以是PropsKeys联合类型中的任意一个，**类似于for in**
  - （3）使用映射类型创建的新对象类型Type2和Type1结构完全相同
  - （4）映射类型**只能在类型别名中使用**，不能在接口中使用
    ```js
      interface Origin {
        name:string;
        age:number;
      }
      type PartialVersion<T> = {
        [P in keyof T]: T[P] // 先执行keyof T获取到对象类型Props中所有键的联合类型即：name,age,然后K in 就表示K可以是Props中的任意一个
      }
      // 映射为只读类型:
      type PartialVersion<T> = {
        readonly [P in keyof T]: T[P] // 先执行keyof T获取到对象类型Props中所有键的联合类型即：name,age,然后K in 就表示K可以是Props中的任意一个
      }
    ```
  ### 8.索引查询类型: T[P]用来查询属性的类型
    - （1）查询单个索引
    - （2）同时查询多个索引
    ```js
      type Props = { age: number; name: string; isGirl: boolean }
      // 查询单个索引
      type P1 = Props['age'] // Props['age']表示查询类型Props中属性‘age’对应的类型number
      type P2 = Props['a' | 'b'] 
       // 同时查询多个索引
      type P3 = Props[keyof  Props]
    ```
  ### 9.泛型内置工具类型Utility
    - （1）Partial<T>用来构建一个类型，将T的所有属性设置为可选
    - （2）Readonly<T>用来构造一个类型，将T的所有属性都设置为readonly
    - （3）排除类型:Omit<T, K>
    - （4）摘取类型:Pick<T, K>从T中选择一组属性来构造新类型
    - （5）Record<K, T>构造一个对象类型，属性键名为K，属性类型为T
    - （6）NonNullable<T> 会将T中的null和undefined排除  exclude null  and undefined  form T
    - （7）Required<T>将T中的所有属性变成必选
    - （8）ReturnType<T>提取T的返回值类型
    ```js
      interface Person {
        name:string;
        age:number;
        id:string;
      }
      // （1）Partial<T>
      type PartialProps = Partial<Person>;
      // （2）Readonly<T>
      type ReadonlyProps = Readonly<Person>;
      let props: ReadronlyProps = {age: 18, id:'1'};
      props.id = '2' // 无法重新赋值，因为id是只读属性
      // （3） Omit<T, K>
      type NoNamePerson = Omit<Person, 'name'>;
      // （4）Pick<T, K>
      type NamePerson = Pick<Person, 'name' | 'id'>;
      // （5）Record<K, T>
      type  RecordObj = Record<'name' | 'age' | 'id', string[]>
      let obj: RecordObj = {
          name: ['1'],
          age: ['2'],
          id: ['3']
      }
      // (6) NonNullable
      let  foo: string | null  =  'Hello';
      let bar: NonNullable <typeof foo> = foo  // 类型推断为string
      console.log(typeof  bar)
      // (7)ReturnType<T>
      type  ProductFn = (arg: string) :string => {return { name: arg }}
      let str:ReturnType<ProductFn> = {
          name: ''
      }
    ```


# 一：内置类型
  ### 1.类型声明：
  - （1）变量如果是同时进行的声明和赋值，那么TS可以自动对变量进行类型检测！
  - （2）函数除了可以为形参声明类型外，还可以为返回值声明类型
  - （3）类型声明文件中不用使用**import...from...而换成import('...')**
    ```js
      function(a:number):number{
        return a
      }
    ```
  ### 2.TS编译
    -w:仅能监视单个文件的变化,同时监视多个文件：在项目下添加tsconfig.json，然后tsc
  ### 3.类型
    |     **序号**   |     **类型**   |        **例子**       |               **描述**               |                **使用**               |
    | -------------- | -------------- | ----------------------| ------------------------------------ |---------------------------------------|
    |         1      |     number     |       1, -30, 2.5     |              任意数字                |         let age:number = 18           |
    |         2      |     string     |      'hello'          |             任意字符串               |            let name:string            |
    |         3      |     boolean    |     true, false       |                布尔值                |           let name:boolean            |
    |         4      |      字面量    |   let 变量名:字面量   |           限制变量的值为本身         |   let sex: '男' || '女'  sex='男'     |
    |         5      |       any      |                       |                任意类型              |                 描述                  |
    |         6      |     unknown    |                       |             类型安全的any            |                 描述                  |
    |         7      |       void     |    空值(undefined)    |          没有值或者undefined         |         表示没有返回值的函数          |
    |         8      |       never    |        没有值         |            不能是任何值              |        表示永远不会返回结果           |
    |         9      |      object    |   {name:'lisa'}       |            任意JS对象                |       let obj:{name?:string}          |
    |         10     |      array     |        [1,2,3]        |            任意JS数组                |       string[]或者Array<string>       |
    |         11     |      tuple     |        [4,5]          |     元素,TS新增类型,固定长度数组     |                描述                   |
    |        12      |      enum      |      enum(A,B)        |            枚举，TS中新增类型        |                 描述                  |
    | -------------- | -------------- | ----------------------| ------------------------------------ |---------------------------------------|

    - （1）**any**：表示的是任意类型，一个变量如果使用了any相当于对改变量关闭了TS的类型检测。
    - （2）**unknow**:表示未知类型的值。
    - （3）**void**和**never**主要用于**函数的返回值**上。void表示空，以函数为例，**void表示没有返回值**的函数。
    - （4）？在属性后面加上?表示属性是可选的。
    - （5）let arr:number[] = [1,2,3,4] 表示数组的每一项都必须为number类型
    - （6）null和undefined只能赋值给**void和它们自身**，可以使用**string | null | undefined联合类型**，或者**使用--strickNullChecked**关闭该标记校验
    - （7）对象类型
    ```js
      let a:undefined = undefined; // undefined只能赋值给它自身
      let str:null = null; // null只能赋值给它自身
      interface IArr {
        path:string, // 确定属性
        name?:string, // 可选属性
        component?:any, // 可选属性
        children?:Item[], // 可选属性
        [propName:string]: any // 任意属性,Record<string, any> ，索引签名类型,属性个数也可以随意

      };
      interface Fn {
        (name:string):number[]
      };
      const fn:FN = (num) => { };
      let obj = {name:string, [key: string]:string};
      
      // void，never
      function fn():void{
        return null
      }

      function fn():never{
        throw new Error()
      } // 当抛出异常的时候是不会有返回值的
      // never应用一：当一个函数永远不会正常然后时，可以将其返回类型标注为never，用于抛出异常或者无限循环
      // never应用二：never永远无法达到的分支，当一个分支永远不可能被执行时，可以将其判断条件结果的类型标注为never
      function checkStatus(status: 'success' | 'error'):string{
        if(status == 'success'){
          return '操作成功'
        } else if (status ='error') {
          return '操作失败'
        } else {
          // 用来健壮分支
          const exhaustiveCheck:never = status
          throw new Error(`unexpect status:${exhaustiveCheck}`)
        }
      }
      type Method = 'get' | 'post'
      function request(value:Method) {
        switch(value) {
          case 'get':
            break
          case 'post':
            break
          default:
            const n:never = method
        }
      }
      // (形参：类型， 形参：类型) => 返回值类型
      let fn: (a:number, b:number, c:string[]) => number
      // 剩余参数的写法
      function buildName(n1, ...rest:string[]){
        return 'aa' + name
      }
    ```


# 二：类型推导与类型注释与类型断言
  ### 类型推导使用场景
  - 声明变量并初始化时
  - 决定函数返回值时
    ```js
      // =====================类型推导=====================
      let  num = 18
      function  add(num1: number,num2:number){return num1 + num2}
      // =====================类型注释=====================
      let  age: number = 18; // :number就是类型注解,作用：为变量添加类型约束，比如上述就是约束变量age的类型是number类型
      const newAttr = reactive({
        attrName:'',
        attrValue:[] as string[]
      })
      const file = ref([] as UploadFile[])
      
      // =====================类型断言=====================
      const  link =  document.getElementById('link')  as  HTMLAnchorElement
    ```
# 三：联合类型|与交叉类型&
  ```js
    // 由两个或者多个类型组成的类型，表示可以是这些类型中的任意一种
    let  numbers: (number | string)[] = [1, 2, 'a', 'b']

    // 交叉类型：功能类似于接口继承，用于组合多个类型为一个类型（常用于对象类型）
    interface Person ( name: string )
    interface Contact { phone:  string }
    type PersonContact = Person & Contact
    let p : PersonContact = {
      name: 'lisa',
      phone: '18101016666'
    }
  ```

# 四：字面量类型
  ```js
    // 字面量类型
    let count:number
    count = 100 // count可以修改
    let count1:100
    count1 = 200  // 不能将类型“200”分配给类型“100”
    // 字面量类型和联合类型结合使用，提供一个精确的可选范围
    type BtnType = 'success' | 'error' | 'warning' | 'danger'
    let btn:BtnType = 'success'

    function  changeDirection ( direction: 'up' | 'down' | 'left' | 'right'){
      console.log(direction)
    }
  ```

# 五：枚举类
  ```js
    enum Gender{
      Male = 0,
      Female = 1
    }
    console.log(Gender.Male)
    // 数字枚举，字符串枚举，反向映射，异构枚举，常量枚举，枚举成员类型和联合枚举类型，枚举合并
    enum  Derection { Up, Down, Left, Right}
    function  changeDirection ( direction: Direction)  {   console.log(direction)   }
  ```


# 六：函数类型
  ### 1.函数类型定义
  ```js
    // 有返回值
    function add (num1: number, num2: number ) : number {    return num1 + num2    }
    const add = (num1: number, num2: number) : number => {   return num1 + num2  }
    const add: (num1: number, num2: number) => number = (num1, num2) => {
        return num1 + num2
    }
    type  FnType = (num1:number, num2:number)    // 函数类型接口
    const  add:FnType  =  （a, b）=> {  return a + b}
    // 无返回值：此时函数的返回值类型为void
    function test (name: string) : void {
        console.log(name)
    }
    // 函数可选参数 ？
    function fn (num1: number, num2 ?: number) : number {
        return num1 + num2
    }
    console.log( fn(2, 3) )
  ```
  ### 2.函数重载
    ```js
      let user: number[] = [1,2,3]
      function findNum(add:number[]): number[]
      function findNum(id:number): number[]
      function findNum():number[]
      function findNum(ids:number | number[]): number[] {
        if (typeof ids = 'number') {
          return user.filter(el => el == ids)
        } else if (Array.isArray(ids)){
          return user.push(...ids)
        } else {
          return user
        }
      }
    ```
  ### 3.函数注解
    ```js
      type DomEventHandler = e:EventTarget => void
      const ClickHandler: DomEventHandler = e => {}
      const ScrollHandler: DomEventHandler = e => {}
    ```
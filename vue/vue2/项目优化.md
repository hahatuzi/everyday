# 一：将静态加载替换成动态加载,比如路由，组件和图片的引入
  ```js
  import  Hello from './hello,vue'
  //替换成import或者require
  ()=> import('./hello,vue')
  (resolve) => reqiure(['./hello.vue'],resolve)
  ```
  ### 1.在此我找到了几个关于优化后的问题
  #### （1）多次进出同一个异步加载页面是否会造成多次加载组件？
    **答：否，首次需要用到组件时浏览器会发送请求加载组件，加载完将会缓存起来，以供之后再次用到该组件时调用**
  #### （2）在多个地方使用同一个异步组件时是否造成多次加载组件？
      ```js
      //a页面
      export default {
          components: {
              historyTab: resolve => {require(['../../component/historyTab/historyTab.vue'], resolve)},//懒加载
          },
      }

      //b页面
      export default {
          components: {
              historyTab: resolve => {require(['../../component/historyTab/historyTab.vue'], resolve)},//懒加载
          },
      }
      ```
      **答：否，首次需要用到组件时浏览器会发送请求加载组件，加载完将会缓存起来，以供之后再次用到该组件时调用**
  #### （3）如果在两个异步加载的页面中分别同步与异步加载同一个组件时是否会造成资源重用？比如以下情况
      ```js
      //a页面
      import historyTab from '../../component/historyTab/historyTab.vue';
      export default {
          components: {
              historyTab
          },
      }

      //b页面
      export default {
          components: {
              historyTab: resolve => {require(['../../component/historyTab/historyTab.vue'], resolve)},//懒加载
          },
      }
      ```
      　答: 会, 将会造成资源重用, 根据打包后输出的结果来看, a页面中会嵌入historyTab组件的代码, b页面中的historyTab组件还是采用异步加载的方式, 另外打包chunk；
      　　解决方案： 组件开发时， 如果根页面没有导入组件的情况下，而是在其他异步加载页面中同时用到组件， 那么为实现资源的最大利用，在协同开发的时候全部人都使用异步加载组件
  #### （4）在异步加载页面中载嵌入异步加载的组件时对页面是否会有渲染延时影响？
  答：会， 异步加载的组件将会比页面中其他元素滞后出现， 页面会有瞬间闪跳影响；

　　解决方案：因为在首次加载组件的时候会有加载时间， 出现页面滞后， 所以需要合理的进行页面结构设计， 避免首次出现跳闪现象；
  ### 2.vue项目框架设计时的懒加载设计，动态路由和动态组件配合使用addroute
### 二：组件懒加载的方式：component的is属性和computed配合使用，另一种是使用v-if切换
```js
<template>
<component v-bind:is="getCom"></component>
</template>
const child1 = ()=>import('./child1.vue')
const child2 = ()=>import('./child2.vue')
methods:{
    switchPage: function(page){
      switch(page){
        case 'first':{
          this.curPage = FirstComFirst;
          break;
        }
        case 'second':{
          this.curPage = FirstComSecond;
          break;
        }
        case 'third':{
          this.curPage = FirstComThird;
          break;
        }
      }
    }
  },
​
  computed:{
    // 借助计算属性
    getFirstCom: function(){
      return this.curPage;
    }
  }
```
1.首屏优化
2.异步组件加载，什么是异步组件
3.next
4.import和()=>import的区别
https://article.itxueyuan.com/rxZwjm
# 一：虚拟DOM
  ### 1.为什么需要虚拟DOM？
   - （1）vue是数据驱动视图的框架，将template模版通过render函数**先渲染生成全部的虚拟变量**，包括改变和未改变的，然后**再使用path进行diff算法**。
   - （2）跨平台性,通过虚拟DOM实现跨平台开发
  ### 2.为什么有了响应式数据劫持后还需要虚拟DOM？
    因为组件中并非每一个属性都有watcher,这样会导致页面性能大大降低，所以vue最终采用的是**组件级watcher+虚拟DOM**
  ### 2.diff算法
    - 第一步：调用**path方法**，传入新旧虚拟DOM，开始**同层对比**
    - 第二步：调用**isSameNode方法**，对比新旧节点是否为同类型节点
    - 第三步：如果不同，新节点直接代替旧节点
    - 第四步：如果相同，调用**patchNode方法**进行对比节点
      - 新旧节点都是文本节点，新文本替换旧文本
      - 旧节点有子元素，新元素没有，删除旧的子节点
      - 旧节点没有子元素，新元素有，新增新的子节点
      - 都有子节点，调用**updateChildren方法**进行新旧节点对比，对比方法为**首尾对比法**
 - vue在渲染过程中是如何使用**render函数**实现**渲染虚拟dom**的
 - react fiber
 - 

# 二：vue3和vue2对比
  ### 1.v-if和v-for的优先级问题
    ```js
      <div id="app">
      <div v-for="item in [1,2,3,4]" v-if="item !== 2"></div>
      </div>
      // vue2版本
      function render () {
        with(this) {
          return _c('div',{
              attrs: {
                "id":'app'
              }
            }, _l(([1,2,3,4]), function (item) {
              // 会先循环【1，2，3，4],在循环中判断if,如果if不成立就_e()
              return (item !== 2) ? _c('div') : _e()
            })
          )
        }
      }
      // vue3版本
      function render(_ctx, _cache) {
        // vue3会先判断v-if,不存在的话就会创建注释节点
        return (_ctx.item !== 2) ? (
          _openBlock(), _createElementBlock(_fragment, {key:0}, _renderList([1,2,3], item => {
            return _createElementVNode('div')
          }))
        ) : _createComentVnode('v-if', true)
      }
    ```
  ### 2.生命周期钩子函数对比
   - （1）Vue3新增了setup、onRenderTracked和onRenderTriggered等钩子。
     - Vue3中beforeDestroy和destroyed在Vue3中被重命名为onBeforeUnmount和onUnmounted。
     - Vue3中的beforeMount、mounted、beforeUpdate、updated等钩子与Vue2中的对应钩子功能相同。
     - Vue3中的setup
    - 父子组件的生命周期钩子执行顺序
    - 自定义钩子函数
# v-for中的key的作用